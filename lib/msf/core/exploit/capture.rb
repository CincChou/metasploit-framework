#
# -*- coding: binary -*-

require 'packetfu'

module Msf
  ###
  #
  # This module provides methods for sending and receiving
  # raw packets. It should be preferred over the soon-to-be
  # deprecated Rex::Socket::Ip and Msf::Exploit::Remote::Ip
  # mixins.
  #
  # Please see the pcaprub documentation for more information
  # on how to use capture objects.
  #
  ###
  class Exploit
    module Capture
      #
      # Initializes an instance of an exploit module that captures traffic
      #
      def initialize(info = {})
        super

        register_options(
          [
            OptString.new('INTERFACE', [false, 'The name of the interface, or PCAP file if preceeded with file:']),
            Opt::LHOST,
            Opt::RHOST
          ], Msf::Exploit::Capture
        )

        register_advanced_options(
          [
            OptInt.new(
              'GATEWAY_PROBE_SECRET',
              [true, 'A 32-bit cookie for probe requests.', 'MSF!'.unpack('N').first]
            ),
            OptAddress.new(
              'GATEWAY_PROBE_HOST',
              [true, 'Send a TTL=1 random UDP datagram to this host to discover the default gateway\'s MAC', '8.8.8.8' ]
            ),
            OptPort.new(
              'GATEWAY_PROBE_PORT',
              [false, 'The port on GATEWAY_PROBE_HOST to send a random UDP probe to (random if 0 or unset)']
            )
          ],
          Msf::Exploit::Capture
        )
      end

      def stats_recv(pcap = @capture)
        return(0) unless pcap
        pcap.stats['recv']
      end

      def stats_drop(pcap = @capture)
        return(0) unless pcap
        pcap.stats['drop']
      end

      def stats_ifdrop(pcap = @capture)
        return(0) unless pcap
        pcap.stats['ifdrop']
      end

      def pcap_on_windows?
        RUBY_PLATFORM =~ /mswin|mingw|cygwin/
      end

      def network_interfaces
        if pcap_on_windows?
          require 'network_interface'
          return NetworkInterface.interfaces
        end

        Socket.getifaddrs.map(&:name).compact.uniq
      end

      def network_addresses(dev)
        if pcap_on_windows?
          require 'network_interface'
          return NetworkInterface.addresses(dev)
        end

        addrs = {
          Socket::AF_PACKET => [],
          Socket::AF_INET => [],
          Socket::AF_INET6 => []
        }

        Socket.getifaddrs.each do |i|
          next unless i.name == dev
          case i.addr.afamily
          when Socket::AF_PACKET
            addrs[i.addr.afamily] << {
              'addr' => i.addr.inspect_sockaddr.split('hwaddr=')[1].chomp(']'),
              'netmask' => nil,
              'broadcast' => 'ff:ff:ff:ff:ff:ff'
            }
          when Socket::AF_INET, Socket::AF_INET6
            addrs[i.addr.afamily] << {
              'addr' => i.addr ? i.addr.ip_address : nil,
              'netmask' => i.netmask ? i.netmask.ip_address : nil,
              'broadcast' => i.broadaddr ? i.broadaddr.ip_address : nil
            }
          end
        end
        addrs
      end

      def interface_info(dev)
        unless network_interfaces.include?(dev)
          dev = dev.to_s.sub('eth', '').to_i
          dev = network_interfaces[dev]
        end
        raise "Interface #{dev} does not exist" if !dev
        [dev, network_addresses(dev)]
      end

      def require_pcap
        begin
          require 'pcaprub'
        rescue ::LoadError
          raise "Capture not available"
        end
      end

      def pcap_file?(file)
        if file.length > 24
          magic = file.unpack('N')[0]
          return magic == 0xa1b23c4d || magic == 0x4d3cb2a1
        end
        return false
      end

      #
      # Opens a handle to the specified device
      #
      def open_pcap(dev: nil, snaplen: 65535, filter: nil, timeout: 1, do_arp: true)
        require_pcap
        dev ||= datastore['INTERFACE']

        if pcap_file?(dev)
          @capture = ::Pcap.open_offline(dev)
        else
          dev, _addrs = interface_info(dev)
          dev ||= ::Pcap.lookupdev

          system("ifconfig", dev, "up") unless pcap_on_windows?

          @capture = ::Pcap.open_live(dev, snaplen, true, timeout)

          if do_arp
            preamble = datastore['GATEWAY_PROBE_SECRET'].to_i
            arp_filter = "arp[6:2] = 2 or (udp[8:4] = #{preamble})"
            @arp_capture = ::Pcap.open_live(dev, 512, true, timeout)
            @arp_capture.setfilter(arp_filter)
          end
        end

        if !@capture
          raise "Could not start the capture process"
        elsif do_arp && !@arp_capture && pcapfile.empty?
          raise "Could not start the ARP capture process"
        end

        @capture.setfilter(filter) if filter
        @capture
      end

      def close_pcap
        @capture     = nil
        @arp_capture = nil
      end

      def capture_extract_ies(raw)
        set = {}
        idx = 0

        while idx < raw.length
          len = raw[idx + 1]
          return set unless len
          set[raw[idx]] ||= []
          set[raw[idx]].push(raw[idx + 2, len])
          idx += len + 2
        end

        return set
      end

      #
      # Loop through each packet
      #
      def each_packet
        return unless capture
        @capture_count ||= 0
        capture.each do |pkt|
          yield(pkt)
          @capture_count += 1
        end
        @capture_count
      end

      # Injects a packet on the wire. For all injection-related functions, it's
      # on the module to open up a capture device first (this way, we don't
      # needlessly spawn new capture devices).
      def inject(pkt = "", pcap = @capture)
        if !pcap
          raise "Could not access the capture process (remember to open_pcap first!)"
        else
          #$stderr.puts("writing #{pkt} to #{pcap}")
          pcap.inject(pkt.to_s) # Can be a PacketFu Packet object or a pre-packed string
        end
      end

      # Injects an Ethernet packet with an optional payload. The payload
      # may be a regular PacketFu packet, an EthHeader, or a string.
      def inject_eth(eth_daddr: "ff:ff:ff:ff:ff:ff", eth_saddr: "00:00:00:00:00:00",
                     eth_type: 0x0800, payload: nil, pcap: @capture)
        p = PacketFu::EthPacket.new
        p.eth_daddr = eth_daddr
        p.eth_saddr = eth_saddr
        p.eth_proto = eth_type
        if payload
          # Handle binstruct directly
          if payload.respond_to?('to_binary_s')
            p.payload = payload.to_binary_s
          elsif payload.is_a?(String)
            p.payload = payload.to_s
          elsif payload.kind_of?(PacketFu::EthPacket)
            p.payload = payload.eth_header.body
          elsif payload.kind_of?(PacketFu::EthHeader)
            p.payload = payload.body
          end
        end
        p.recalc
        inject(p.to_s, pcap)
      end

      def inject_pcap(pcap_file, filter: nil, delay: 0, pcap: @capture)
        require_pcap
        raise "Could not access the capture process (remember to open_pcap first!)" unless pcap
        raise "The PCAP file #{pcap_file} could not be found" if !File.exist?(pcap_file)
        raise "The PCAP file #{pcap_file} is empty" if pcap_file.empty?

        capture_file = ::Pcap.open_offline(pcap_file)
        capture_file.setfilter(filter) if filter
        while (pkt = capture_file.next)
          pcap.inject(pkt)
          sleep((delay * 1.0) / 1000)
        end
      end

      # Sends a payload to a given target using the pcap capture interface
      #
      # == Parameters:
      # payload:: The payload String to send
      # dhost:: the destination host to send to
      # bcast:: set to `true` to send to the broadcast address if necessary
      # dev:: the name of the network interface to send the payload on
      #
      # == Returns:
      # The number of bytes sent iff the payload was successfully sent/injected.  `false` otherwise
      def capture_sendto(payload = "", dhost = nil, bcast = false)
        raise "Could not access the capture process (remember to open_pcap first!)" unless @capture
        raise "Must specify a host to sendto" unless dhost
        dev ||= datastore['INTERFACE']
        dst_mac, src_mac = lookup_eth(dhost, dev)
        if dst_mac.nil? && !bcast
          vprint_error("Unable to determine the destination MAC for #{dhost} on #{dev} and bcast is false")
          return false
        end
        inject_eth(payload: payload, eth_daddr: dst_mac, eth_saddr: src_mac)
      end

      # The return value either be a PacketFu::Packet object, or nil
      def inject_reply(proto = :udp, pcap = @capture)
        # Defaults to ~2 seconds
        to = ((datastore['TIMEOUT'] || 500).to_f * 4) / 1000.0
        raise "Could not access the capture process (remember to open_pcap first!)" if !pcap
        begin
          ::Timeout.timeout(to) do
            pcap.each do |r|
              packet = PacketFu::Packet.parse(r)
              next unless packet.proto.map { |x| x.downcase.to_sym }.include? proto
              return packet
            end
          end
        rescue ::Timeout::Error
        end
        nil
      end

      # This ascertains the correct Ethernet addresses one should use to
      # ensure injected IP packets actually get where they are going, and
      # manages the arp_cache hash. It always uses @arp_capture
      # to inject and capture packets, and will always first fire off a
      # UDP packet using the regular socket to learn the source host's
      # and gateway's mac addresses.
      def lookup_eth(addr = nil, iface = nil)
        raise "Could not access the capture process." unless @arp_capture

        if iface == 'lo'
          return ["00:00:00:00:00:00", "00:00:00:00:00:00"]
        end

        @arp_cache ||= {}
        @dst_cache ||= {}

        return @dst_cache[addr] if @dst_cache[addr]

        probe_gateway(addr) if !@arp_cache[Rex::Socket.source_address(addr)]
        src_mac = @arp_cache[Rex::Socket.source_address(addr)]

        if should_arp?(addr)
          dst_mac = @arp_cache[addr] || arp(addr)
        else
          dst_mac = @arp_cache[:gateway]
        end

        @dst_cache[addr] = [dst_mac, src_mac]
      end

      def probe_gateway(addr)
        dst_host = datastore['GATEWAY_PROBE_HOST']
        dst_port = datastore['GATEWAY_PROBE_PORT'] ? datastore['GATEWAY_PROBE_PORT'] : rand(1024..65535)
        preamble = [datastore['GATEWAY_PROBE_SECRET']].pack("N")
        secret = "#{preamble}#{Rex::Text.rand_text(rand(0xff) + 1)}"

        begin
          UDPSocket.open do |sock|
            sock.setsockopt(::Socket::IPPROTO_IP, ::Socket::IP_TTL, 1)
            sock.send(secret, 0, dst_host, dst_port)
          end
        rescue Errno::ENETUNREACH
          # This happens on networks with no gateway. We'll need to use a
          # fake source hardware address.
          @arp_cache[Rex::Socket.source_address(addr)] = "00:00:00:00:00:00"
        end

        begin
          to = ((datastore['TIMEOUT'] || 500).to_f * 8) / 1000.0
          ::Timeout.timeout(to) do
            loop do
              my_packet = inject_reply(:udp, @arp_capture)
              next unless my_packet
              next unless my_packet.payload == secret
              dst_mac = @arp_cache[:gateway] = my_packet.eth_daddr
              src_mac = @arp_cache[Rex::Socket.source_address(addr)] = my_packet.eth_saddr
              return [dst_mac, src_mac]
            end
          end
        rescue ::Timeout::Error
          # Well, that didn't work (this is common on networks where there's no gateway, like
          # VMWare network interfaces. We'll need to use a fake source hardware address.
          @arp_cache[Rex::Socket.source_address(addr)] = "00:00:00:00:00:00"
        end
      end

      # A pure-Ruby ARP exchange. It uses @arp_capture to send and recv
      # packets, rather than @capture.
      def arp(target_ip = nil)
        return @arp_cache[target_ip] if @arp_cache[target_ip]
        return @arp_cache[:gateway] unless should_arp? target_ip
        source_ip = Rex::Socket.source_address(target_ip)
        raise "Could not access the capture process." unless @arp_capture

        p = arp_packet(target_ip, source_ip)

        # Try up to 3 times to get an ARP response
        1.upto(3) do
          inject_eth(
            eth_type: 0x0806,
            payload:   p,
            pcap:      @arp_capture,
            eth_saddr: @arp_cache[Rex::Socket.source_address(target_ip)]
          )
          begin
            to = ((datastore['TIMEOUT'] || 500).to_f * 8) / 1000.0
            ::Timeout.timeout(to) do
              loop do
                my_packet = inject_reply(:arp, @arp_capture)
                next unless my_packet
                next unless my_packet.arp_saddr_ip == target_ip
                @arp_cache[target_ip] = my_packet.eth_saddr
                return @arp_cache[target_ip]
              end
            end
          rescue ::Timeout::Error
          end
        end
        nil
      end

      # Creates a full ARP packet, mainly for use with inject_eth()
      def arp_packet(target_ip = nil, source_ip = nil)
        p               = PacketFu::ARPPacket.new
        p.arp_opcode    = 1
        p.arp_daddr_ip  = target_ip || datastore['RHOST']
        p.arp_saddr_ip  = source_ip || datastore['LHOST']
        my_eth          = @arp_cache[Rex::Socket.source_address(target_ip)]
        p.arp_saddr_mac = my_eth || "00:00:00:00:00:00"
        return p
      end

      # Allow modules to reset their arp caches arbitrarily.
      def expire_arpcache
        @arp_cache = {}
      end

      # For compatibilty with Msf::Exploit::Remote::Ip
      def lhost
        datastore['LHOST']
      end

      def rhost
        datastore['RHOST']
      end

      def should_arp?(ip)
        require_pcap
        dev = datastore['INTERFACE'] || ::Pcap.lookupdev
        begin
          my_ip, my_mask = Pcap.lookupnet(dev)
          # convert the netmask obtained from the relevant interface to CIDR
          cidr_mask = my_mask.to_s(2).count('1')
          my_net = IPAddr.new("#{my_ip}/#{cidr_mask}")
        rescue RuntimeError => e
          @pcaprub_error = e
          print_status("Cannot stat device: #{@pcaprub_error}")
          raise "Capture error: #{@pcaprub_error}"
        end
        my_net.include?(IPAddr.new(ip))
      end

      attr_accessor :capture, :arp_cache, :arp_capture, :dst_cache

      def get_mac(dev)
        dev, addrs = interface_info(dev)
        raise "Cannot get mac address for interface #{dev}" if !addrs[Socket::AF_PACKET][0]['addr']
        addrs[Socket::AF_PACKET][0]['addr']
      end

      def get_ipv4_addr(dev, num = 0)
        dev, addrs = interface_info(dev)
        raise "Interface #{dev} does not have an IPv4 address at position #{num}" if addrs[Socket::AF_INET].length < num + 1
        raise "Cannot get the IPv4 address for interface #{dev}" if !addrs[Socket::AF_INET][num]['addr']
        addrs[Socket::AF_INET][num]['addr']
      end

      def get_ipv6_addr(dev, num = 0)
        dev, addrs = interface_info(dev)
        raise "Interface #{dev} do not have an IPv6 address at position #{num}" if addrs[Socket::AF_INET6].length < num + 1
        raise "Cannot get IPv6 address for interface #{dev}" if !addrs[Socket::AF_INET6][num]['addr']
        addrs[Socket::AF_INET6][num]['addr'].gsub(/%(.)*$/, '')
      end
    end
  end
end
